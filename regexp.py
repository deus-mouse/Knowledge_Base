# -*- coding: utf-8 -*-

#
# 15.03 Regular Expressions
#

# Regexp - способ посика совпадений шаблона с текстом

# . - любой одиночный символ
# [ ] - любой из них, диапазоны
# $ - конец строки
# ^ - начало строки
# \ - экранирование
# \d - любую цифру
# \D - все что угодно, кроме цифр
# \s - пробелы
# \S - все кроме пробелов
# \w - буква
# \W - все кроме букв
# \b - граница слова
# \B - не границ
#
# Квантификация
# n{4} - искать n подряд 4 раза
# n{4,6} - искать n от 4 до 6
# * от нуля и выше
# + от 1 и выше
# ? - нуль или 1 раз
# (\s|-) - либо то (пробел), либо это (дефис)



# Проверить телефон +7 920 072 95 04        ^\+\d\s\d{3}\s\d{3}\s\d{2}\s\d{2}
# +7 920 072 95 04 | 7(920)072-95-04        ^\+?\d[ |\(]\d{3}[ |\)]\d{3}[ |\-]\d{2}[ |\-]\d{2}




# В python с регулярными выражениями работает модуль re
import re

# И ознакомимся с его основными функциями:
# Первая из них match, которая зачастую работает быстрее других фукнций поиска,
# т.к. ищет совпадения только с начала строки
matched_at_begin = re.match(nemo_pattern, deep_ocean)
print(matched_at_begin)     # None

# search() же производит поиск по всему тексту, но только до первого совпадения
matched = re.search(nemo_pattern, deep_ocean)
print(f'Возвращается объект {matched} внутри которого содержится информация о совпадении')  # re.Match object

# Эту информацию можно извлечь следующими методами:
print(f'Подстрока, совпавшая с паттерном поиска {matched.group()}')  # type 'str'
print(f'Индекс начала этой подстроки {matched.start()}')  # 'int'
print(f'И индекс её окончания {matched.end()}')  # 'int'

# Чтобы получить не только первый результат поиска
# мы можем воспользоваться итератором:
searching_iterator = re.finditer(nemo_pattern, deep_ocean)
for matched in searching_iterator:
    # сам по себе итератор будет возвращать объекты класса re.Match, как делал re.search
    print(f'Следующее совпадение: {matched.group()}')  # 'str'

full_search = re.findall(nemo_pattern, deep_ocean)
print(f'Список со всеми совпадениями паттерна, найденными во всем тексте {full_search}')  # 'list'

# Однако мы можем использовать эту информацию для уточнения шаблона
final_matched = re.search('Nemo', deep_ocean)
print(f'Возвращение объекта с нужным совпадением {final_matched}')  # re.Match object
print(f'Уточнение индекса начала {final_matched.start()}')
print(f'И конца {final_matched.end()}')


# Функция sub позволяет не только осуществлять поиск, но и заменять найденное
transparent = re.sub(r'[Oo]\w{4}', '', deep_ocean)
print('Всё, что совпало с паттерном было заменено, осталось лишь')
print(transparent)

# Чтобы избавиться от пустот и оставить лишь наших рыбок, можно немного изменить шаблон
cleared = re.sub(r'[Oo]\w{4}\s+', '', deep_ocean)
print('Теперь в тексте остались лишь упоминания наших рыбок')
print(cleared)

# В дополнение к этой функции, есть ещё одна, способная разделять текст как str.split() только
# в качестве разделителя используя заданную подстроку
separation = re.split('nemoO', cleared)
print(f'Список из частей, между котороыми был найден наш паттерн {separation}')  # 'list'

# Функция fullmatch() очень придирчива и возвращает результат только в случае полного совпадения
full_match = re.fullmatch('Marlin nemaa nemoO nenemo Nemo', cleared)
print(f'Полного совпадения найдено не было {full_match}')  # None
full_match = re.fullmatch('Marlin nemaa nemoO nenemo Nemo ', cleared)
print(f'А вот теперь совпадение нашлось {full_match}')  # re.Match object
# А вы нашли отличие?


###
# Особенности синтаксиса регулярных выражений

# OR в регулярных выражениях:
# в регулярных выражениях существует аналог питоновскому or, это символ '|'
# Он позволяет связать два шаблона в один, и если строка подойдёт хотя бы к одному из них, то она подойдёт
# этому новому шаблону.
# Так строка подходящая к шаблону А или к шаблону B подойдёт к шаблону A|B
# Например, отдельные овощи в тексте можно искать при помощи шаблона 'морковк|св[её]кл|картошк|редиск'

# Экранирование:
# В пайтоне, символ '\', который в обычных строках означает экранирование последующего символа.
# Т.к. в регулярных выражениях большинство символов используют '\' (\d,\w...)
# Нам придётся экранировать их каждый раз (\\d, \\w...)
# Чтобы избежать этого, перед строкой добавляют литерал r, который сообщает пайтону о том, что
# воспринимать '\' можно не как экранирующий символ.
# Однако!
# Среди специальных символов регулярных выражений есть те, которые не используют '\'
# Например '.'
# Но вдруг нам в тексте необходимо будет найти именно точку?
# Её придётся всё же экранировать слэшем '\.'

# В примере \(.*\) экранированы символы скобок.
# Если бы мы этого не сделали, скобки были бы приняты за специальные символы
# Которые означают группировку, суть которой мы рассмотрим позже




###
# Проблемы регулярных выражений

# К примеру одной из распространенных задачек, при изучении регулярных выражений, является валидация email.
# И хоть сами по себе задачки интересные, делать так на реальных примерах не стоит.
# В отсутствии четких требований к регистрации e-mail адресов, растет и размер регулярных выражений.
# Вот пример одного из таких выражений:

# (?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b
# \x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@(?:(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])
# ?|\[(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|[a-z0-9-]*[a-z0-9]:
# (?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21-\x5a\x53-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])+)\])


###
# Подводя итог, надо признать что RegExp-ы очень мощное средство для решения задач обработки текста.
# Но, как любое мощное средство, требует аккуратного обращения. Дабы не выстрелить себе в ногу.
