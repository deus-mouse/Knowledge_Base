# https://leetcode.com/explore/interview/card/top-interview-questions-easy/99/others/565/

'''
Write a function that takes the binary representation of a positive integer and returns the number of set bits it has (also known as the Hamming weight).
'''


class Solution:
    def hammingWeight(self, n: int) -> int:
        # Преобразуем число в двоичную строку и подсчитываем единицы
        return bin(n).count('1')
        # Временная сложность:
        # O(1) - хотя метод count проходит по всей двоичной строке,
        # длина этой строки для 32-битного числа ограничена 32 символами,
        # что делает время выполнения постоянным в контексте размера входных данных.
        # Пространственная сложность:
        # O(1) - используется константное количество дополнительной памяти,
        # не зависящее от размера входных данных.

    def hammingWeight_GPT(self, n: int) -> int:
        # Метод Брайана Кернигана, который последовательно сбрасывает самый правый установленный бит числа
        count = 0
        while n:
            n = n & (n - 1)  # Сбрасывает самый правый установленный бит
            print(f'{n=}, {bin(n)=}')  # n=2147483644, bin(n)='0b1111111111111111111111111111100'
            count += 1
        return count
        # Этот метод работает за время, пропорциональное количеству установленных битов,
        # что может быть особенно выгодно для чисел с небольшим количеством единиц в двоичном представлении,
        # уменьшая количество итераций в сравнении с подходом,
        # основанным на прямом подсчете единиц в двоичной строке.








s = Solution()
print(s.hammingWeight(11))
print(s.hammingWeight_GPT(2147483645))