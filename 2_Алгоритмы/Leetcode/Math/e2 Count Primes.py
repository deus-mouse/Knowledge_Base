# https://leetcode.com/explore/interview/card/top-interview-questions-easy/102/math/744/

'''
Given an integer n, return the number of prime numbers that are strictly less than n.


'''


# Для нахождения количества простых чисел, строго меньших данного числа n, можно использовать алгоритм решета Эратосфена. Этот метод позволяет эффективно находить все простые числа до заданного числа n за время O(n log log n).
#
# Алгоритм:
# Создаем булев массив isPrime размером n, где каждый элемент инициализирован значением True, кроме isPrime[0] и isPrime[1], которые инициализированы False, поскольку 0 и 1 не являются простыми числами.
# Проходим по массиву начиная с числа 2 (первое простое число) до n и для каждого числа, если оно является простым, обозначаем все его кратные (начиная с i2) как составные (не простые), устанавливая в isPrime значение False.
# Подсчитываем количество элементов в isPrime, которые остались True (кроме 0 и 1), что соответствует количеству простых чисел меньше n.

class Solution:
    def countPrimes(self, n: int) -> int:
        if n <= 2:  # Если n меньше или равно 2, простых чисел нет
            return 0

        isPrime = [True] * n  # Инициализация списка для отметки простых чисел
        isPrime[0] = isPrime[1] = False  # 0 и 1 не являются простыми числами

        # алгоритм решета Эратосфена
        for i in range(2, int(n ** 0.5) + 1):  # Перебор чисел до корня из n
            if isPrime[i]:  # Если число i простое
                for j in range(i * i, n, i):  # Помечаем кратные i как составные
                    isPrime[j] = False

        return sum(isPrime)  # Подсчитываем количество простых чисел




s = Solution()
print(s.countPrimes(10))  # Вывод: 4
print(s.countPrimes(0))   # Вывод: 0
print(s.countPrimes(1))   # Вывод: 0
